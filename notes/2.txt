# Intuition
my first intuition was a very slow one and wasteful, my first instinct was to loop though the list of numbers  
and based on their position add them to create and int, add both and separate them into a final list

this is very tedious and slow, so after some research and gathering some ideas i found a better and simpler way to look at the problem

# Approach
the approach for the best solution is to create an empty list for the answer and a carry variable,  then while the first, second and carry 
are not null we build our answer by adding the values of the nodes and updating the carry depending if the mod 10 of the sum
is > 0, we create the new node and set curr.next to this new node, advace all pointers and repeat.

# Complexity
- Time complexity:
for the time complexity we are looping though the length of the largest list so O(N) n being max(len(l1), len(l2))

- Space complexity:
we are creating a new list so the complexity for space is O(N)

# Code
```python3 []
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1:Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        carry = 0
        head = ListNode(0)
        curr = head
        while l1 != None or l2 != None or carry != 0: #stop algorith if l1 and l2 are none and carry is also 0
            num1 = l1.val if l1 else 0 # get the head of the linked lists
            num2 = l2.val if l2 else 0

            currentSum = num1 + num2 + carry #calculate the current sum of iteration
            carry = currentSum // 10 # calculate the carry
            newNode = ListNode(currentSum%10) #create a new node, make sure its less than 10
            curr.next = newNode #update answer of linked list

            curr = newNode # advance pointers
            l1 = l1.next if l1 else None 
            l2 = l2.next if l2 else None
        return head.next

```